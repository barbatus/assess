# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateBook {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregateUserBook {
  _avg: UserBookAvgAggregate
  _count: UserBookCountAggregate
  _max: UserBookMaxAggregate
  _min: UserBookMinAggregate
  _sum: UserBookSumAggregate
}

type Book {
  _count: BookCount
  author: String!
  cover: String
  id: Int!
  title: String!
  users(cursor: UserBookWhereUniqueInput, distinct: [UserBookScalarFieldEnum!], orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): [UserBook!]!
}

type BookAvgAggregate {
  id: Float
}

input BookAvgOrderByAggregateInput {
  id: SortOrder
}

type BookCount {
  users: Int!
}

type BookCountAggregate {
  _all: Int!
  author: Int!
  cover: Int!
  id: Int!
  title: Int!
}

input BookCountOrderByAggregateInput {
  author: SortOrder
  cover: SortOrder
  id: SortOrder
  title: SortOrder
}

input BookCreateInput {
  author: String!
  cover: String
  title: String!
  users: UserBookCreateNestedManyWithoutBookInput
}

input BookCreateNestedOneWithoutUsersInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUsersInput
  create: BookCreateWithoutUsersInput
}

input BookCreateOrConnectWithoutUsersInput {
  create: BookCreateWithoutUsersInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutUsersInput {
  author: String!
  cover: String
  title: String!
}

type BookGroupBy {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
  author: String!
  cover: String
  id: Int!
  title: String!
}

type BookMaxAggregate {
  author: String
  cover: String
  id: Int
  title: String
}

input BookMaxOrderByAggregateInput {
  author: SortOrder
  cover: SortOrder
  id: SortOrder
  title: SortOrder
}

type BookMinAggregate {
  author: String
  cover: String
  id: Int
  title: String
}

input BookMinOrderByAggregateInput {
  author: SortOrder
  cover: SortOrder
  id: SortOrder
  title: SortOrder
}

input BookOrderByWithAggregationInput {
  _avg: BookAvgOrderByAggregateInput
  _count: BookCountOrderByAggregateInput
  _max: BookMaxOrderByAggregateInput
  _min: BookMinOrderByAggregateInput
  _sum: BookSumOrderByAggregateInput
  author: SortOrder
  cover: SortOrder
  id: SortOrder
  title: SortOrder
}

input BookOrderByWithRelationInput {
  author: SortOrder
  cover: SortOrder
  id: SortOrder
  title: SortOrder
  users: UserBookOrderByRelationAggregateInput
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

enum BookScalarFieldEnum {
  author
  cover
  id
  title
}

input BookScalarWhereWithAggregatesInput {
  AND: [BookScalarWhereWithAggregatesInput!]
  NOT: [BookScalarWhereWithAggregatesInput!]
  OR: [BookScalarWhereWithAggregatesInput!]
  author: StringWithAggregatesFilter
  cover: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type BookSumAggregate {
  id: Int
}

input BookSumOrderByAggregateInput {
  id: SortOrder
}

input BookTitleAuthorCompoundUniqueInput {
  author: String!
  title: String!
}

input BookUpdateInput {
  author: StringFieldUpdateOperationsInput
  cover: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  users: UserBookUpdateManyWithoutBookNestedInput
}

input BookUpdateManyMutationInput {
  author: StringFieldUpdateOperationsInput
  cover: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BookUpdateOneRequiredWithoutUsersNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUsersInput
  create: BookCreateWithoutUsersInput
  update: BookUpdateWithoutUsersInput
  upsert: BookUpsertWithoutUsersInput
}

input BookUpdateWithoutUsersInput {
  author: StringFieldUpdateOperationsInput
  cover: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BookUpsertWithoutUsersInput {
  create: BookCreateWithoutUsersInput!
  update: BookUpdateWithoutUsersInput!
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  author: StringFilter
  cover: StringNullableFilter
  id: IntFilter
  title: StringFilter
  users: UserBookListRelationFilter
}

input BookWhereUniqueInput {
  id: Int
  title_author: BookTitleAuthorCompoundUniqueInput
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createOneBook(data: BookCreateInput!): Book!
  createOneUser(data: UserCreateInput!): User!
  createOneUserBook(data: UserBookCreateInput!): UserBook!
  deleteManyBook(where: BookWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyUserBook(where: UserBookWhereInput): AffectedRowsOutput!
  deleteOneBook(where: BookWhereUniqueInput!): Book
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneUserBook(where: UserBookWhereUniqueInput!): UserBook
  updateManyBook(data: BookUpdateManyMutationInput!, where: BookWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyUserBook(data: UserBookUpdateManyMutationInput!, where: UserBookWhereInput): AffectedRowsOutput!
  updateOneBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUserBook(data: UserBookUpdateInput!, where: UserBookWhereUniqueInput!): UserBook
  upsertOneBook(create: BookCreateInput!, update: BookUpdateInput!, where: BookWhereUniqueInput!): Book!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserBook(create: UserBookCreateInput!, update: UserBookUpdateInput!, where: UserBookWhereUniqueInput!): UserBook!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateBook(cursor: BookWhereUniqueInput, orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): AggregateBook!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateUserBook(cursor: UserBookWhereUniqueInput, orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): AggregateUserBook!
  book(where: BookWhereUniqueInput!): Book
  books(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!
  findFirstBook(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstBookOrThrow(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserBook(cursor: UserBookWhereUniqueInput, distinct: [UserBookScalarFieldEnum!], orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): UserBook
  findFirstUserBookOrThrow(cursor: UserBookWhereUniqueInput, distinct: [UserBookScalarFieldEnum!], orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): UserBook
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getBook(where: BookWhereUniqueInput!): Book
  getUser(where: UserWhereUniqueInput!): User
  getUserBook(where: UserBookWhereUniqueInput!): UserBook
  groupByBook(by: [BookScalarFieldEnum!]!, having: BookScalarWhereWithAggregatesInput, orderBy: [BookOrderByWithAggregationInput!], skip: Int, take: Int, where: BookWhereInput): [BookGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByUserBook(by: [UserBookScalarFieldEnum!]!, having: UserBookScalarWhereWithAggregatesInput, orderBy: [UserBookOrderByWithAggregationInput!], skip: Int, take: Int, where: UserBookWhereInput): [UserBookGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  userBook(where: UserBookWhereUniqueInput!): UserBook
  userBooks(cursor: UserBookWhereUniqueInput, distinct: [UserBookScalarFieldEnum!], orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): [UserBook!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  _count: UserCount
  books(cursor: UserBookWhereUniqueInput, distinct: [UserBookScalarFieldEnum!], orderBy: [UserBookOrderByWithRelationInput!], skip: Int, take: Int, where: UserBookWhereInput): [UserBook!]!
  email: String!
  id: Int!
  name: String!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserBook {
  book: Book!
  bookId: Int!
  date: DateTime!
  id: Int!
  rating: Int
  status: String!
  user: User!
  userId: Int!
}

type UserBookAvgAggregate {
  bookId: Float
  id: Float
  rating: Float
  userId: Float
}

input UserBookAvgOrderByAggregateInput {
  bookId: SortOrder
  id: SortOrder
  rating: SortOrder
  userId: SortOrder
}

type UserBookCountAggregate {
  _all: Int!
  bookId: Int!
  date: Int!
  id: Int!
  rating: Int!
  status: Int!
  userId: Int!
}

input UserBookCountOrderByAggregateInput {
  bookId: SortOrder
  date: SortOrder
  id: SortOrder
  rating: SortOrder
  status: SortOrder
  userId: SortOrder
}

input UserBookCreateInput {
  book: BookCreateNestedOneWithoutUsersInput!
  date: DateTime!
  rating: Int
  status: String!
  user: UserCreateNestedOneWithoutBooksInput!
}

input UserBookCreateNestedManyWithoutBookInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutBookInput!]
  create: [UserBookCreateWithoutBookInput!]
}

input UserBookCreateNestedManyWithoutUserInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
}

input UserBookCreateOrConnectWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateWithoutBookInput {
  date: DateTime!
  rating: Int
  status: String!
  user: UserCreateNestedOneWithoutBooksInput!
}

input UserBookCreateWithoutUserInput {
  book: BookCreateNestedOneWithoutUsersInput!
  date: DateTime!
  rating: Int
  status: String!
}

type UserBookGroupBy {
  _avg: UserBookAvgAggregate
  _count: UserBookCountAggregate
  _max: UserBookMaxAggregate
  _min: UserBookMinAggregate
  _sum: UserBookSumAggregate
  bookId: Int!
  date: DateTime!
  id: Int!
  rating: Int
  status: String!
  userId: Int!
}

input UserBookListRelationFilter {
  every: UserBookWhereInput
  none: UserBookWhereInput
  some: UserBookWhereInput
}

type UserBookMaxAggregate {
  bookId: Int
  date: DateTime
  id: Int
  rating: Int
  status: String
  userId: Int
}

input UserBookMaxOrderByAggregateInput {
  bookId: SortOrder
  date: SortOrder
  id: SortOrder
  rating: SortOrder
  status: SortOrder
  userId: SortOrder
}

type UserBookMinAggregate {
  bookId: Int
  date: DateTime
  id: Int
  rating: Int
  status: String
  userId: Int
}

input UserBookMinOrderByAggregateInput {
  bookId: SortOrder
  date: SortOrder
  id: SortOrder
  rating: SortOrder
  status: SortOrder
  userId: SortOrder
}

input UserBookOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserBookOrderByWithAggregationInput {
  _avg: UserBookAvgOrderByAggregateInput
  _count: UserBookCountOrderByAggregateInput
  _max: UserBookMaxOrderByAggregateInput
  _min: UserBookMinOrderByAggregateInput
  _sum: UserBookSumOrderByAggregateInput
  bookId: SortOrder
  date: SortOrder
  id: SortOrder
  rating: SortOrder
  status: SortOrder
  userId: SortOrder
}

input UserBookOrderByWithRelationInput {
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  date: SortOrder
  id: SortOrder
  rating: SortOrder
  status: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum UserBookScalarFieldEnum {
  bookId
  date
  id
  rating
  status
  userId
}

input UserBookScalarWhereInput {
  AND: [UserBookScalarWhereInput!]
  NOT: [UserBookScalarWhereInput!]
  OR: [UserBookScalarWhereInput!]
  bookId: IntFilter
  date: DateTimeFilter
  id: IntFilter
  rating: IntNullableFilter
  status: StringFilter
  userId: IntFilter
}

input UserBookScalarWhereWithAggregatesInput {
  AND: [UserBookScalarWhereWithAggregatesInput!]
  NOT: [UserBookScalarWhereWithAggregatesInput!]
  OR: [UserBookScalarWhereWithAggregatesInput!]
  bookId: IntWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  rating: IntNullableWithAggregatesFilter
  status: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type UserBookSumAggregate {
  bookId: Int
  id: Int
  rating: Int
  userId: Int
}

input UserBookSumOrderByAggregateInput {
  bookId: SortOrder
  id: SortOrder
  rating: SortOrder
  userId: SortOrder
}

input UserBookUpdateInput {
  book: BookUpdateOneRequiredWithoutUsersNestedInput
  date: DateTimeFieldUpdateOperationsInput
  rating: NullableIntFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutBooksNestedInput
}

input UserBookUpdateManyMutationInput {
  date: DateTimeFieldUpdateOperationsInput
  rating: NullableIntFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input UserBookUpdateManyWithWhereWithoutBookInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithWhereWithoutUserInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithoutBookNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutBookInput!]
  create: [UserBookCreateWithoutBookInput!]
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutBookInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutBookInput!]
}

input UserBookUpdateManyWithoutUserNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutUserInput!]
}

input UserBookUpdateWithWhereUniqueWithoutBookInput {
  data: UserBookUpdateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithWhereUniqueWithoutUserInput {
  data: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithoutBookInput {
  date: DateTimeFieldUpdateOperationsInput
  rating: NullableIntFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutBooksNestedInput
}

input UserBookUpdateWithoutUserInput {
  book: BookUpdateOneRequiredWithoutUsersNestedInput
  date: DateTimeFieldUpdateOperationsInput
  rating: NullableIntFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input UserBookUpsertWithWhereUniqueWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  update: UserBookUpdateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpsertWithWhereUniqueWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  update: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUserIdBookIdCompoundUniqueInput {
  bookId: Int!
  userId: Int!
}

input UserBookWhereInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  date: DateTimeFilter
  id: IntFilter
  rating: IntNullableFilter
  status: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserBookWhereUniqueInput {
  id: Int
  userId_bookId: UserBookUserIdBookIdCompoundUniqueInput
}

type UserCount {
  books: Int!
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  id: Int!
  name: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserCreateInput {
  books: UserBookCreateNestedManyWithoutUserInput
  email: String!
  name: String!
}

input UserCreateNestedOneWithoutBooksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutBooksInput
  create: UserCreateWithoutBooksInput
}

input UserCreateOrConnectWithoutBooksInput {
  create: UserCreateWithoutBooksInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutBooksInput {
  email: String!
  name: String!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  email: String!
  id: Int!
  name: String!
}

type UserMaxAggregate {
  email: String
  id: Int
  name: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

type UserMinAggregate {
  email: String
  id: Int
  name: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithRelationInput {
  books: UserBookOrderByRelationAggregateInput
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  email
  id
  name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  books: UserBookUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutBooksNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutBooksInput
  create: UserCreateWithoutBooksInput
  update: UserUpdateWithoutBooksInput
  upsert: UserUpsertWithoutBooksInput
}

input UserUpdateWithoutBooksInput {
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutBooksInput {
  create: UserCreateWithoutBooksInput!
  update: UserUpdateWithoutBooksInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  books: UserBookListRelationFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}